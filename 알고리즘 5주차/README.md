# 프로그래머스 <막대, 도넛, 8자 그래프>
https://school.programmers.co.kr/learn/courses/30/lessons/258711
 - 모든 그래프를 순회할 필요 x
 - 각 노드들의 In, Out 간선갯수만 체크
 - Out이 0인 정점 => 막대그래프의 갯수++;
 - Out이 1인 정점 => 일반적인 모든 정점->고려x;
 - Out >=2 && In == 0 => 새로 생성한 정점;
 - Out >=2 && In >0 인 정점 => 8자 그래프의 중심 정점 -> 8자그래프++;
 - 도넛 그래프 ==> (새로 생성한 정점의 Out간선 갯수) - (막대그래프 갯수) - (8자그래프 갯수);


# 프로그래머스 : 입국심사 <이분탐색, 형변환>
- long long ex = (long long)int변수 * (long long)int변수; 로 써야함
- int x int 는 최대 int임 애초에 long long으로 변환을 못함. long long으로 둘 다 바꿔줘야 long long 범위에 들어가는 값이 나옴

  //////////////
  
  처음에 middle 값을 대충 정함
  middle 시간안에 처리할 수 있는 총 사람수를 구함(totalTime += mid/c);
  
 1. [해당시간에 처리할수 있는 사람수]와 [목표 사람수]를 비교함
 
 2. [처리할수 있는 사람수]가 [처리해야되는 사람수]보다 많으면 시간을 너무 여유있게 잡았음 -> 시간을 줄여봄

 3. [처리할수 있는 사람수]가 [처리해야되는 사람수]보다 적으면 시간을 너무 빡빡하게 잡았음 -> 시간을 늘려봄
   
 4. [처리할수 있는 사람수]와 [처리해야되는 사람수]가 같으면
      순서는 모르겠지만 아무튼 시간은 구했다! 끝



# 백준 3584 공통조상찾기(LCA)
- 그래프 문제는 단순히 전부 둘러보는 필요는 없음. DFS같은 문제나 재귀를 요구하지 않는 한;
- 1차원 배열을 생성
- 트리 구조에서는 1개의 부모는 여러개의 자식을 두지만 ,, 1개의 자식은 무조건 1개의 부모를 가짐
 <평소 배열 생성과정과 반대로 생각하기!>
- 루트 노드의 부모는 0이라 칭하고 임의의 노드의 부모를 찾아 올라가면서 방문을 표시

 
